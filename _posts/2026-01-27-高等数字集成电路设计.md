---
title: 高等数字集成电路设计
description: 高等数字集成电路设计
author: Hatrix
date: 2026-01-27 07:52:00 +0800
categories: []
tags: []
math: true
mermaid: true
pin: false
image:
  path: https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/c7e60454de8e3902967bf972fefd77ee.jpeg
  alt: AMD EPYC 9004服务器处理器
---

## 二进制编码

数字信号是离散信号的数字化表示，其变化量是最小量的整数倍，表示方法是二值逻辑/二进制。计算机使用二进制表示信息，这些二进制数就是所谓的代码，给每一组代码赋予一定的含义就是编码。编码有有权码和无权码之分，常见的有权码有 8421 码、5421 码、2421 码等，无权码有余三码、余三循环码、格雷码等。二进制在物理实现上用高低电平两种状态进行表示，电信号的状态易于区分、抗干扰能力较强。二值逻辑在实现上需要对逻辑电平的标准有统一的规定，即高电平和低电平的电压范围，常用的标准有 TTL、CMOS、RS232。不同标准对高低电平的定义不尽相同，使用不同逻辑电平标准的器件时，就需要电平转换芯片充当翻译的角色，使信息能够被准确传递。

相较于十进制，二进制在表示同样的数时需要更多的位数，用加权的方式，可以在不同数制之间互相转化。二进制只是一种十进制以外的数制，其运算规则与十进制无异。一个数叫一位，8 位叫一个字节；二进制中，1kb 为 1024 byte。大部分计算机用第一位表示正负，剩下位数表示数字。在机器中使用的连同符号一起数码化的二进制数称为机器数，机器数对应的真正数值称为真值。8 位机器数表示的真值范围为 0-255，16 位真值表示的真值范围为 0-65535。

数据可用科学计数法表示，根据小数点的位置是否固定分为定点数和浮点数。浮点数表示法中以一定的位宽分别表示符号、阶数和尾数，阶数的位宽决定可以表示数据的范围，尾数的位决定可以表示数据的精度。为了解决编码空间浪费的问题，一般规定尾数的第一位为 1，以 0.1xxx 的形式表示，这一过程称为归一化；为了使阶数可以表示负指数，给阶数部分加上一个根据位宽而定的居中的数作为偏置，负指数加上偏置后变为正指数。IEEE-754 为国际通用的浮点数标准。

![](https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/20250912171328931.png)

文字按照一定的编码方式对应为一串二进制数，因此也可由几位二进制数表示。ASCII 用 7 位二进制数表示字母，数字，标符号和特殊命令符号。而对于中文和日文这样有成千上万个字符的语言，各国有不同的多字节编码方案，但互不兼容。为此诞生了 Unicode，统一了所有的编码标准，最常见的 Unicode 是 16 位的。音频是时间上的一维信号，图片/颜色是二维的矩阵或者张量信号，视频则是由一帧帧图片构成，这些信息均可以由二进制编码。

## 布尔代数及实现

布尔代数是专门研究二值逻辑的数学结构，真值表是其中的重要工具，用于列举逻辑表达式(逻辑函数)在所有可能输入情况下的结果。在设计逻辑电路的过程中，需要对逻辑函数进行化简，可以使用公式、卡诺图、QM 法等方法完成操作，常见公式和方法具体步骤的资料丰富，此处省略。布尔代数定义了与、或、非、与非、或非、异或、同或七种基本运算。基本运算叠加复合，可以构成许多实用的逻辑函数。有了逻辑函数的概念后，还需要用电路去实现，以 TTL 和 CMOS 与非门为例，内部结构分别如下

![image-20250331142933733](https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/image-20250331142933733.png)

利用二极管、三极管、场效应管等晶体管，可以构成全部七种能完成基本运算的逻辑门，实际使用时都是封装好的成熟芯片，故一般无需掌握其内部结构，但对芯片数据手册中的常用参数(阈值电压、噪声容限、扇出系数、传输延迟时间、动态尖峰电流等)需要了解含义以便选型。除了七种基本逻辑运算，OC/OD 门和三态门也是常用的两种逻辑门，OC/OD 门的逻辑功能和普通逻辑门相同，但内部结构有所不同，用于配合上拉电阻用于实现线与的逻辑(线与多根信号线连在一起，一根信号线输出低电平则整个输出低电平)，其电路符号和普通逻辑门相同。三态门用于实现信号的分时复用，三态即除了高低电平外还有高阻态，高阻态是一种特殊的 “断开” 状态，此时接口在电气上与外部电路几乎隔离，不影响其他电路的工作，通常用于避免总线上的数据冲突。

![image-20250331143009173](https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/image-20250331143009173.png)

## 组合逻辑

组合逻辑电路由逻辑门构成，任意时刻的输出仅取决于该时刻的输入，无反馈环节或记忆能力，功能可以完全分解成布尔表达式描述。以二输入的组合逻辑函数，穷举出来共有十六种，在 FPGA 中可以将所有十六种函数通过类似开关的机制做成一个叫做查找表 LUT （二输入查找表）的基本结构里。  

![image-20260127141944447](https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/image-20260127141944447.png)

对于较复杂的逻辑函数，同一个函数存在不同的实现方式，不同实现方式的实现面积和关键路径延时可能有所差别。实现面积即电路用晶体管实现后在芯片上占用的面积，面积在芯片设计中被视为一种重要的资源，关系到芯片的散热、集成的规模等等。关键路径指逻辑电路中信号传递经过的最长路径的耗时，包括导线延时和逻辑延时，逻辑延时即逻辑门 CMOS 充电到目标电平需要的时间。从输入到输出经过的逻辑门的串联层数称为逻辑级数，是组合逻辑深度的衡量。较少的逻辑级数通常可以降低信号传输延时。减少逻辑级数，本质是用复杂的单级门替代简单的多级门，单级门的晶体管数量（门级开销）会有所增加。实现面积和逻辑门延时往往是一对矛盾的指标，需要设计者在面积和速度之间进行权衡。

设计组合逻辑电路的大致思路为：确定输入输出，列出真值表，化简逻辑函数，用逻辑门实现。常用的逻辑功能基本都有封装好的成熟芯片，用 Verilog 也可以很方便地搭建且可以自己定制实现方式，可使用这些组件进行更高层次的设计，比如级联或构成功能丰富的系统。

![image-20250331143401460](https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/image-20250331143401460.png)

常用的逻辑电路模块举例如下

- 全加器：一位二进制数的加法，考虑进位；可级联成多位的加法器；配合补码的概念也可实现减法
- 数据选择器：在多个输入信号中选择一个传输到输出；可级联扩大选择范围
- 多路分配器：将一个输入信号选择传输到多个输出中的一个；可级联扩大选择范围
- 数值比较器：比较两个相同位数的二进制数的大小，可用于标志位的产生；可级联增加比较的位数
- 编码器：将一组二进制代码赋予特定的含义(如表示为对应的十进制数)；可级联增加支持的线数
- 译码器：输入二进制代码，输出还原之后的特定输出信号；可级联增加支持的线数；将输出信号接到发光二极管上，就是所谓的显示译码器；当每个输出都是输入变量的最小项时，又称为最小项译码器。最小项译码器可以实现当前输入个数下的任意逻辑函数

## 时序逻辑

时序逻辑电路由逻辑门和存储器构成，输出与之前输出状态有关，有反馈环节和记忆能力。时序逻辑电路接收信号之前的状态称为初态/原态，用 $Q^n$ 表示，接收信号之后建立的新稳态称为次态/新态，用 $Q^{n+1}$ 表示。所谓有记忆能力，就是指次态同时由输入和初态决定。相较于组合逻辑电路的输入而言，时序逻辑电路更重要的往往是时钟信号/触发信号的输入。复杂系统中，往往用时钟信号/触发信号来保证各个信号的动作在时间上同步。时序逻辑电路的表示方式有时钟方程+驱动方程+输出方程+状态方程，状态转换图，次态卡诺图等。

存储器的基本单元是触发器(Flip-Flop，简称 FF)，基本 RS 触发器也叫锁存器(latch)，其基本结构和真值表如下，通过改变输入信号，可以实现对状态 Q 的存储、置位和复位。锁存器可用于实现门控时钟，一般用于低功耗设计中，可有效消除毛刺，但初学者不建议使用。

![image-20250331144256376](https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/image-20250331144256376.png)

触发器可以存储一位的信息，将它们并排使用便可以存储更多位数的信息，比如存储八位信息的寄存器、移位寄存器等更复杂的存储结构。触发器按逻辑函数实现的功能又细分为 RS 触发器、JK 触发器、D 触发器、T 触发器、T\'触发器；按结构又细分为基本型触发器、同步型触发器、主从型触发器、边沿型触发器。触发器有电平触发和边沿触发，狭义上的触发器指边沿触发，而电平触发的叫锁存器。寄存器的基本组成单元为触发器/锁存器。而缓冲器与三者不同，没有数据保存的功能而更像是一个开关，主要用于隔离和增强信号的驱动能力。Verilog 设计中用到的触发器一般指边沿触发的 D 触发器。

时序逻辑中最常用的结构是计数器，由触发器和逻辑门构成。触发器之间采用不同的连接方式，可以跳过某些计数值从而实现任意进制的计数器、环形计数器、扭环形计数器等多种衍生功能。

<img src="https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/20250921110020824.png" style="zoom: 67%;" alt=""/>

计数器分为同步计数器和异步计数器，同步计数器所有位的触发器均受时钟信号约束，工作频率高、传输延迟短、结构复杂；而异步计数器低位输出直接控制高位输入，结构简单，存在竞争和冒险产生的尖峰脉冲。下图左侧为同步计数器结构，右侧为异步计数器结构。

![image-20250331144459251](https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/image-20250331144459251.png)

有限状态机 FSM 是时序逻辑中应用最广泛的模型。状态机推荐都写成三段式，逻辑清晰方便调试，一个时序 always 块用于描述当前状态，一个组合 always 块用于描述状态转移，一个时序或组合 always 块用于描述输出。下面是一个例子（为了聚焦于状态机模板本身，删掉了实际的功能，所以从功能上看起来只向外发起了一个 rd_req）

```verilog
module read_cam
(
	input clk,
	input rstn,
	input in_ready,
	input in_valid,
	input rd_global_done,
	output reg rd_req
);
	localparam IDLE  = 3'd0;
    localparam CAM_0 = 3'd1;
    localparam CAM_1 = 3'd2;
    localparam CAM_2 = 3'd3;
    localparam CAM_3 = 3'd4;
    localparam CAM_4 = 3'd5;
    localparam DONE  = 3'd6;
	reg[2:0] state_cur, state_next;
    // 描述当前状态
	always @ (posedge clk) begin
		if (!rstn) begin
			state_cur <= IDLE;
		end
		else begin
			state_cur <= state_next;
		end
	end

    // 描述状态转移
	always @ (*) begin
		state_next <= state_cur;
		case (state_cur)
			IDLE:  if (in_ready) state_next <= CAM_0;
            CAM_0: if (in_valid) state_next <= CAM_1;
            CAM_1: if (in_valid) state_next <= CAM_2;
            CAM_2: if (in_valid) state_next <= CAM_3;
            CAM_3: if (in_valid) state_next <= CAM_4;
            CAM_4: if (in_valid) state_next <= DONE;
            DONE:  if (rd_global_done) state_next <= DONE;
			default: state_next <= IDLE;
		endcase
	end

    // 描述输出
	always @ (posedge clk) begin
		if (!rstn) begin
			rd_req <= 0;
		end
		else begin
            if ((state_cur == IDLE) && (in_ready)) begin
				rd_req <= 1;
			end
			else begin
				rd_req <= 0;
			end
		end
	end
endmodule
```

状态机有 Mealy 和 Moore 型之分，前者的状态机输出与当前状态和输入有关，在输入变化不同步的情况下可能引入时序问题，通常会实现成两段式；后者的状态机输出只和当前状态有关，通常实现成三段式。初学者建议一律实现成三段式的 Moore 型状态机。

## 算术逻辑

算术逻辑是组合逻辑中最重要的一类功能，例如加法器、乘法器和浮点预算等。计算机的整数运算系统中，数字一律被编码为二进制的补码。正数的补码和原码一致，负数的补码为原码按位取反再加一。下面对加法器、乘法器以及浮点运算的几种常见形式做一个概览介绍，具体实现这里先空着。

加法器的基本元件为半加器和全加器，由它们可构成行波进位加法器（串行进位加法器）、超前进位加法器、线性进位选择加法器等不同的加法器结构。相较于串行进位，后两者优化的关键在于并行地提前计算各位的进位，消除了高低进位之间的依赖关系，用面积换速度。此外还有通常以阵列形式使用的进位保留加法器。

![image-20260127151606223](https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/image-20260127151606223.png)

二进制乘法的本质是计算部分积累加，优化的关键也在于减少部分积求和的次数。阵列乘法器是一种常用的实现方式，由半加器、全加器和与门构成。此外还有加入一定时序逻辑的顺序乘法器、通过编码来减少部分积次数的 Booth 乘法器、部分积压缩网络 Wallance Tree 等。 

![image-20260127151934945](https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/image-20260127151934945.png)

浮点数的运行普遍会比定点数复杂，所以一般先对数据作定点化，以定点化的形式完成处理后再转为浮点数。计算机的位宽是有限的，而实数域是无限的，当浮点运算结果超过尾数能表达的位宽时，一定会产生误差，位宽越大，误差越小。此时需要对数据进行舍入，最简单的舍入方式是直接舍掉多余的位，但一般误差较大。此外还有就近舍入，原理与十进制的四舍五入完全相同，将数据根据小数部分的值不同，向临近整数舍入。浮点数的加法需要统一阶数、尾数相加、最后归一化结果；浮点数的乘法需要指数相加、尾数相乘、归一化结果。

## 片上存储器

根据数据访问的局部性原理，现代计算机的存储系统设计呈现明显的层级结构，片上存储器属于离 CPU 最近的部分，容量小读写快，有寄存器堆和 SRAM 两种形式。

![image-20260127203140473](https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/image-20260127203140473.png)

寄存器堆即多个寄存器构成的阵列，可以基于分离触发器的排列组合，可多个端口同时读写，用于 CPU 中的通用寄存器；也可以基于快速 SRAM 架构，一般只能两个端口读写，用于芯片上的数据快速存储。 寄存器堆在实际实现时需要考虑扇入扇出的负载与速度之间的平衡，堆中的寄存器越多，扇入扇出负载越大，速度越慢；还需要注意读写口的数量直接影响寄存器堆的复杂度和规模。为保证访问速度，寄存器堆一般实现成小规模。

![image-20260127200959767](https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/image-20260127200959767.png)

SRAM 是结构规整、密度更高的存储器，是除了寄存器之外最快的存储介质，功耗和成本也相对高。 通过小规模 SRAM 的组合，可构建交织存储器阵列，用于应对大量数据的并行乱序随机访问。

![image-20260127201040827](https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/image-20260127201040827.png)

Cache 存储架构，配合《计算机体系结构量化研究方法》看，先空着。

## 时钟和时序

时钟信号最重要的参数包括频率/周期、占空比、上升/下降时间、时钟抖动等，在实现上会使用专门的振荡器或晶振产生固定频率的方波信号。基本的时钟控制包括锁相环 PLL 和延迟锁相环 DLL。PLL 通过闭环控制电压，由压控振荡器将输出频率锁定为参考频率的 (N/R) 倍，实现频率合成与相位同步，用于频率合成，有相位积累误差；DLL 用可控延迟线作反馈将时钟相位对齐，用于相位调节，可用作多相时钟或将不同时钟相位对齐。 

![image-20260127205613113](https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/image-20260127205613113.png)

门控时钟是 ASIC 设计中用于降低芯片功耗的常见方式，即控制时钟使能，让某一部分寄存器在不需要工作时不再翻转，可以显著降低动态功耗；具体方式上有 Latch 门控、触发器门控、可测性门控等。不过初学者不建议采用门控时钟设计。

![image-20260127210933555](https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/image-20260127210933555.png)

下面介绍一些概念。

同步时钟和异步时钟：时钟有同步时钟和异步时钟之分，同步时钟是指时钟源相同，频率相位有一定关系的时钟；否则为异步时钟。时钟源不同，则频率和相位没有任何关系；因为自然界没有任何两个完全相同的晶振，因此不同源时钟的频率和相位没有任何关系。

建立时间和保持时间：建立时间是指时钟上升沿到来之前，数据必须保持稳定的时间；保持时间是指时钟上升沿到来之后，数据必须保持稳定的时间。保存时间的意义在于源寄存器的输出不能太快到达目标寄存器，以防止新数据冲掉原来的数据。保持时间是对当前时钟沿而不是下一个时钟沿的约束。由于数据在时钟的上升沿被锁存，因此数据需要在时钟的上升沿的建立时间和保持时间内稳定不变。建立时间和保持时间由器件特性决定，在完成芯片选型后就随之确定。

![image-20251213230104938](https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/222.png)

数据到达路径和数据需求路径：数据到达路径是指数据在两个寄存器间传输的实际路径，由此可推算出数据在两个寄存器间传输的实际时间。数据到达路径的起点是时钟沿，经过源寄存器的时钟输入端口、源寄存器的数据输出端口，最终到达目的寄存器的输入端口。数据需求路径是指为了确保稳定可靠且有效的传输（即满足相应的建立时间和保持时间要求），数据在两个寄存器之间传输的理论所需时间的计算路径。数据需求路径的起点也是时钟源，终点是目的寄存器的时钟输入端口。

![image-20251210145804924](https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/111.png)

时钟模型要求的两个公式如下

$$
\begin{aligned}
&T_{\text{clk}} \geqslant T_{\text{co}} + T_{\text{logic}} + T_{\text{routing}} + T_{\text{setup}} - T_{\text{skew}}\\
&T_{\text{co}} + T_{\text{logic}} + T_{\text{routing}} \geqslant T_{\text{h}} + T_{\text{skew}}
\end{aligned}
$$

![image-20251214214938561](https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/555.png)

其中 $$T_{\text{clk}}$$ 为系统所能达到的最小时钟周期，$$T_{\text{co}}$$ 为源寄存器时钟到输出的时间，$$T_{\text{logic}}$$ 为组合逻辑延迟，$$T_{\text{routing}}$$ 为两级寄存器之间的布线延迟，$$T_{\text{su}}$$ 为建立时间，$$T_{\text{h}}$$ 为保持时间，$$T_{\text{skew}}$$ 为时钟倾斜。$$T_{\text{co}}$$、$$T_{\text{su}}$$、$$T_{\text{h}}$$ 都取决于芯片工艺，在芯片型号选定后就确定了，因此确定芯片后，只能通过 $$T_{\text{logic}}$$ 和 $$T_{\text{routing}}$$ 来改善 $$T_{\text{clk}}$$。其中 $$T_{\text{logic}}$$ 取决于 RTL 代码设计，$$T_{\text{routing}}$$ 取决于布局布线策略。$$T_{\text{skew}}$$ 在 FPGA 的同步时钟设计中一般忽略，因为 FPGA 中的时钟树会尽量保证到达每个寄存器的延迟相同。

## 高层次综合

暂时还没到这一步，先空着。

## 并行技术

这里介绍空间并行和流水线并行两种并行技术。

空间并行实质上就是用面积换速度，通过多个完全相同的并行处理单元来提高系统性能，典型应用比如 ping-pong 操作。在中间组合逻辑的运算所需时间超过一个时钟周期，且逻辑不易分割时，也可以采用这种技术来减少大运算逻辑对系统速率的影响，根据需要复制一个或多个本体逻辑并用 Mux 选择输出，本质上是让其它所需时间小于一个时钟周期的步骤多处理一些数据来填满运算缺口，消除 bubble。

![image-20260127225324629](https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/image-20260127225324629.png)

下面重点介绍流水线并行技术。流水线技术的思想非常朴素，将一个重复的时序过程分解为若干个子过程，每个子过程都可有效地在其专用功能段上与其它子过程同时执行。每个子过程称为流水线的“级”或“段”，由专用的功能段实现，段的数目称为流水线的深度。

![image-20260127215851763](https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/image-20260127215851763.png)

流水线需要等待第一个任务流出之后，流水过程才进入稳定工作状态，每一拍流出一个结果。各个功能段所需时间应尽量相等（这个时间通常为一个时钟周期，称为一拍），否则时间长的段会成为瓶颈，造成流水线堵塞或断流。流水线适合大量重复的时序工作，只有输入端能连续地提供任务，才能充分发挥流水线的效率。

流水线性能的常用量化指标如下，T 为时钟周期

- 最大吞吐量：若每个时钟周期能从流水线输出一个结果，则最大吞吐量为 $$f=\frac{1}{T}$$
- 加速比：一条 K 段流水线处理 n 个任务，花费总时间为 $$T_k = [K+(n-1)]T$$，加速比为 K 段流水线对等效非流水线的加速因子 $$S_k = \frac{T_1}{T_k} = \frac{nKT}{[K+(n-1)]T} = \frac{nK}{K+n-1}$$
- 流水线频率：$$E_k = \frac{S_k}{K} = \frac{n}{K+n-1}$$，$$n\to \infty$$ 时效率接近 1
- 吞吐率：单位时间执行的操作数，$$H_k=\frac{n}{[K+(n-1)]T} = \frac{nf}{K+(n-1)}$$，$$n\to \infty$$ 时得到最大吞吐率

流水线的工作过程可用时空图来描述，横坐标代表时间，纵坐标代表流水线的各个段。

![image-20260127222328232](https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/image-20260127222328232.png)

流水线分静态流水线和动态流水线，前者用来实现确定的功能，只有当输入是一串相同的运算操作时，才能充分发挥效率；后者除了流水线连接外还允许前馈和反馈连接，又称非线性流水线，可处理非相同运算的一串操作，控制更加复杂。

![image-20260127222629470](https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/image-20260127222629470.png)

对于具有瓶颈段的流水线，可采用细分瓶颈或重复设置瓶颈段的方式来提高效率。

![image-20260127223011609](https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/image-20260127223011609.png)

非线性流水线举例如下，由于存在反馈，流水线中存在冲突的可能，因此一个重要的问题是确定什么时候向流水线引入新的输入才能使得输入的数据和先前操作的反馈数据在流水线中不冲突，也就是所谓的流水线调度问题。 

![image-20260127223108888](https://cdn.jsdelivr.net/gh/HatrixXXX/Hatrix-s-Blog-Image/img/image-20260127223108888.png)

非线性流水线相关的内容暂时用不到，先空着。

## 可重构设计技术

阵列设计、存储层次、控制流处理

## 参考资料

[纸上谈芯](https://www.zhihu.com/people/zhishangtanxin/posts)

[超前进位加法器 LCA](https://zhuanlan.zhihu.com/p/101332501)

[线性进位选择加法器](https://wzf2000.top/xzc0072010/5474/)

[booth 乘法](https://www.cnblogs.com/gujiangtaoFuture/articles/12163087.html)

[PLL 原理](https://www.bilibili.com/video/BV1yS4y1n7vV/)

[DLL 原理](https://blog.csdn.net/vivid117/article/details/108102272)

## 附录

### 时钟控制设计规则

Rule1：设计流程中尽早确定时钟分布架构，预判时钟结构影响；大型高速芯片的平衡时钟树等策略需早规划，避免时钟 buffer 占用大量功耗与面积

Rule2：时钟产生和控制逻辑从所有功能模块分离，放入独立模块

- Guideline1：使用尽量少的时钟完成设计，不同时钟域同步逻辑独立为小模块，便于 ASIC 综合、约束与分析
- Guideline2：片内 PLL 产生时钟时，设置 PLL 无效或旁路机制，方便芯片测试与调试
- Guideline3：避免使用上升沿和下降沿同时触发的逻辑

Rule3：同时使用上升沿和下降沿有效触发器时，综合与时序分析需建模最坏时钟占空比，并记录占空比要求作为系统时钟约束

- Guideline4：考虑将上升沿、下降沿触发器分模块放置
- Guideline5：Clock Buffers 在物理设计阶段考虑；RTL 阶段将时钟视为无延迟理想网络，不例化 Clock Buffer
- Guideline6：避免片内产生时钟（易引发测试问题，时钟驱动逻辑无法作为扫描链部分）；添加测试电路旁路内部时钟，使扫描链由同一时钟控制

Guideline7：避免在 RTL 设计时对时钟进行门控

Guideline8：若 RTL 设计需手动时钟门控，将其分离到顶层独立模块，且手动门控仅在此顶层模块出现

Guideline9：划分设计，保证每个模块有单一的时钟，且模块内部不对时钟进行门控

Guideline10：RTL 设计用门控时钟降功耗时，不直接对时钟门控，采用同步装入寄存器的描述风格（推荐 `always @(posedge clk) if(使能信号)`，避免 `assign 门控时钟=clk and 使能` 的写法）
